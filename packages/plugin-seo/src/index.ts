import { NoxionPlugin, BlogPost } from '@noxion/types'

export interface SEOConfig {
  generateMetaTags: boolean
  enableOpenGraph: boolean
  enableTwitterCards: boolean
  enableJsonLd: boolean
  defaultImage: string
  siteName: string
  twitterHandle?: string
  facebookAppId?: string
  autoGenerateDescriptions: boolean
  maxDescriptionLength: number
  keywords: string[]
}

export const createSEOPlugin = (config: Partial<SEOConfig> = {}): NoxionPlugin => {
  const defaultConfig: SEOConfig = {
    generateMetaTags: true,
    enableOpenGraph: true,
    enableTwitterCards: true,
    enableJsonLd: true,
    defaultImage: '/og-default.jpg',
    siteName: 'Noxion Blog',
    autoGenerateDescriptions: true,
    maxDescriptionLength: 160,
    keywords: ['blog', 'noxion', 'cms'],
    ...config
  }

  return {
    name: 'seo-optimizer',
    version: '2.1.0',
    description: 'Comprehensive SEO optimization plugin with meta tags, Open Graph, and structured data',
    author: 'Noxion Team',
    dependencies: ['analytics'], // Depends on analytics for tracking
    config: defaultConfig,
    
    async register(context) {
      // Registering SEO Plugin
      
      // Hook into post rendering to add SEO metadata
      context.registerHook('afterPostRender', async (post: BlogPost) => {
        const enhancedPost = await enhancePostWithSEO(post, defaultConfig)
        
        if (defaultConfig.generateMetaTags) {
          // SEO: Meta tags generated
        }
        
        return enhancedPost
      })
      
      // Hook into posts query to optimize list pages
      context.registerHook('afterPostsQuery', async (posts: BlogPost[]) => {
        return posts.map(post => generateListPageSEO(post, defaultConfig))
      })
      
      // Register SEO components
      context.registerComponent('SEOHead', createSEOMetadata(defaultConfig))
      
      context.registerComponent('StructuredData', createStructuredDataComponent(defaultConfig))
      
      context.registerComponent('SEOAnalytics', createSEOAnalyticsComponent(defaultConfig))
    }
  }
}

async function enhancePostWithSEO(post: BlogPost, config: SEOConfig): Promise<BlogPost> {
  const seoData = {
    title: generateSEOTitle(post.title, config),
    description: generateSEODescription(post, config),
    keywords: [...config.keywords, ...extractKeywords(post)],
    image: post.cover || config.defaultImage,
    url: `/articles/${post.slug}`,
    publishedTime: post.createdAt,
    modifiedTime: post.updatedAt,
    author: post.author || 'Noxion Team',
  }
  
  return {
    ...post,
    seo: seoData
  }
}

function generateListPageSEO(post: BlogPost, config: SEOConfig): BlogPost {
  return {
    ...post,
    listSeo: {
      snippet: generateSEODescription(post, config, 120), // Shorter for lists
      image: post.cover || config.defaultImage
    }
  }
}

function generateSEOTitle(title: string, config: SEOConfig): string {
  if (title.includes(config.siteName)) {
    return title
  }
  return `${title} | ${config.siteName}`
}

function generateSEODescription(post: BlogPost, config: SEOConfig, maxLength?: number): string {
  const length = maxLength || config.maxDescriptionLength
  
  if (post.description && post.description.length <= length) {
    return post.description
  }
  
  if (config.autoGenerateDescriptions && post.content) {
    // Extract first paragraph and truncate
    const firstParagraph = post.content.split('\n\n')[0]
    const cleanText = firstParagraph.replace(/[#*`]/g, '').trim()
    
    if (cleanText.length <= length) {
      return cleanText
    }
    
    return cleanText.substring(0, length - 3) + '...'
  }
  
  return post.description || `Read more about ${post.title} on ${config.siteName}`
}

function extractKeywords(post: BlogPost): string[] {
  // Simple keyword extraction from title and content
  const text = `${post.title} ${post.content || ''}`.toLowerCase()
  const words = text.match(/\b\w{4,}\b/g) || []
  
  // Count word frequency and return top keywords
  const frequency: Record<string, number> = {}
  words.forEach(word => {
    frequency[word] = (frequency[word] || 0) + 1
  })
  
  return Object.entries(frequency)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 5)
    .map(([word]) => word)
}

function createSEOMetadata(config: SEOConfig) {
  return function generateSEOMetadata(post?: BlogPost) {
    if (!post?.seo) return {}
    
    const { seo } = post
    const metadata: any = {
      title: seo.title,
      description: seo.description,
    }
    
    if (config.generateMetaTags) {
      metadata.keywords = seo.keywords
      metadata.authors = [{ name: seo.author }]
    }
    
    if (config.enableOpenGraph) {
      metadata.openGraph = {
        title: seo.title,
        description: seo.description,
        images: seo.image ? [seo.image] : [],
        url: seo.url,
        type: 'article',
        siteName: config.siteName,
        publishedTime: seo.publishedTime,
        modifiedTime: seo.modifiedTime,
      }
      
      if (config.facebookAppId) {
        metadata.openGraph.appId = config.facebookAppId
      }
    }
    
    if (config.enableTwitterCards) {
      metadata.twitter = {
        card: 'summary_large_image',
        title: seo.title,
        description: seo.description,
        images: seo.image ? [seo.image] : [],
      }
      
      if (config.twitterHandle) {
        metadata.twitter.site = config.twitterHandle
        metadata.twitter.creator = config.twitterHandle
      }
    }
    
    return metadata
  }
}

function createStructuredDataComponent(config: SEOConfig): any {
  return function StructuredData({ post }: { post?: BlogPost }) {
    if (!post?.seo || !config.enableJsonLd) return null
    
    const { seo } = post
    const structuredData = {
      '@context': 'https://schema.org',
      '@type': 'BlogPosting',
      headline: seo.title,
      description: seo.description,
      image: seo.image,
      url: seo.url,
      datePublished: seo.publishedTime,
      dateModified: seo.modifiedTime,
      author: {
        '@type': 'Person',
        name: seo.author
      },
      publisher: {
        '@type': 'Organization',
        name: config.siteName
      }
    }
    
    return {
      type: 'script',
      props: {
        type: 'application/ld+json',
        dangerouslySetInnerHTML: {
          __html: JSON.stringify(structuredData)
        }
      }
    }
  }
}

function createSEOAnalyticsComponent(config: SEOConfig): any {
  return function SEOAnalytics() {
    return {
      type: 'div',
      props: {
        className: 'seo-analytics p-4 border rounded',
        children: [
          {
            type: 'h3',
            props: { children: 'SEO Status' }
          },
          {
            type: 'ul',
            props: {
              children: [
                { type: 'li', props: { children: `Meta Tags: ${config.generateMetaTags ? '✅' : '❌'}` }},
                { type: 'li', props: { children: `Open Graph: ${config.enableOpenGraph ? '✅' : '❌'}` }},
                { type: 'li', props: { children: `Twitter Cards: ${config.enableTwitterCards ? '✅' : '❌'}` }},
                { type: 'li', props: { children: `Structured Data: ${config.enableJsonLd ? '✅' : '❌'}` }},
                { type: 'li', props: { children: `Auto Descriptions: ${config.autoGenerateDescriptions ? '✅' : '❌'}` }}
              ]
            }
          }
        ]
      }
    }
  }
}

export default createSEOPlugin